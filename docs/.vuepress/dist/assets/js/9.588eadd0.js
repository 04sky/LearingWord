(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{316:function(e,a,s){"use strict";s.r(a);var t=s(7),v=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"redis-大key问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-大key问题"}},[e._v("#")]),e._v(" Redis 大Key问题")]),e._v(" "),a("p",[e._v("在实际场景或面试中，常会遇到Redis 大Key问题导致性能下降。")]),e._v(" "),a("h2",{attrs:{id:"什么是redis-大key问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis-大key问题"}},[e._v("#")]),e._v(" 什么是Redis 大Key问题")]),e._v(" "),a("p",[e._v("大Key问题主要包含3种类型：")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("value占用体积过大")]),e._v("：一般超过10KB算大；")]),e._v(" "),a("li",[a("code",[e._v("Filed过多")]),e._v("：例如在删除Hash接口时，时间复杂度为O(n)，耗时长；")]),e._v(" "),a("li",[a("code",[e._v("单个实例保存Key过多")]),e._v("：一般上亿个算大。")])]),e._v(" "),a("p",[e._v("会导致：")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("命令阻塞")]),e._v("：因为Redis是单线程，可能造成Redis用户或系统操作阻塞。")]),e._v(" "),a("li",[a("code",[e._v("影响IO")]),e._v("：单台实例网络带宽压力过大，传输数据多。")]),e._v(" "),a("li",[a("code",[e._v("节点内存不均/资源倾斜")]),e._v("：在集群模式下，可能出现节点内存不均匀，保存大Key的节点处理压力过大而导致速度下降甚至崩溃。")])]),e._v(" "),a("p",[e._v("在Redis 4.0的异步删除之前，后台运行的key过期删除操作可能会出现执行缓慢，并且由于是系统操作在慢查询没有记录。")]),e._v(" "),a("h2",{attrs:{id:"如何找到redis大key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何找到redis大key"}},[e._v("#")]),e._v(" 如何找到Redis大Key")]),e._v(" "),a("ol",[a("li",[e._v("在redis-cli命令后添加--bigkeys。存在问题：只能获取各个类型的最大的大Key")]),e._v(" "),a("li",[e._v("使用第三方工具。例如：使用Redistools工具包分析rdb文件。")])]),e._v(" "),a("h2",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[e._v("#")]),e._v(" 解决方案")]),e._v(" "),a("h3",{attrs:{id:"针对value体积过大-采用拆分方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#针对value体积过大-采用拆分方案"}},[e._v("#")]),e._v(" 针对Value体积过大，采用拆分方案")]),e._v(" "),a("h4",{attrs:{id:"拆分value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拆分value"}},[e._v("#")]),e._v(" 拆分Value")]),e._v(" "),a("p",[e._v("若Value为一个对象，可以拆成多个<key,value>结构，使用mget方法获取数据。")]),e._v(" "),a("p",[e._v("因为key不同，存储的分片就可能不一样，以此让原本单台Redis实例的压力分散到多个实例上。")]),e._v(" "),a("h4",{attrs:{id:"使用hash存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用hash存储"}},[e._v("#")]),e._v(" 使用Hash存储")]),e._v(" "),a("p",[e._v("类似拆分Value方式，将Value对象使用Hash结构存储，使用hget/hmget获取指定field，使用hset/hmset设置。")]),e._v(" "),a("h3",{attrs:{id:"针对key数量过多-采用-聚合-方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#针对key数量过多-采用-聚合-方案"}},[e._v("#")]),e._v(" 针对Key数量过多，采用“聚合”方案")]),e._v(" "),a("h4",{attrs:{id:"使用hash存储-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用hash存储-2"}},[e._v("#")]),e._v(" 使用Hash存储")]),e._v(" "),a("p",[e._v("当key之间存在联系时，例如同一个对象的属性，使用Hash的field代替原有的key。")]),e._v(" "),a("h4",{attrs:{id:"分桶存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分桶存储"}},[e._v("#")]),e._v(" 分桶存储")]),e._v(" "),a("p",[e._v("当key之间不存在联系时，将所有key分到多个桶里，每个桶形成一个Hash接口。每个Hash的field最好不超过512，100左右合适。")]),e._v(" "),a("p",[e._v("例如：1亿个key，按照每个Hash key有100field，则将分为100万个桶。更新或添加值是先算Hash得到key，然后在hmget(key,field),hset(key,field,value)")]),e._v(" "),a("h2",{attrs:{id:"删除大key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除大key"}},[e._v("#")]),e._v(" 删除大Key")]),e._v(" "),a("p",[e._v("在Redis 4.0之前，不要直接删除，会阻塞命令，利用"),a("code",[e._v("scan")]),e._v("命令迭代大Key的元素，分批删除。\n在Redis 4.0及之后，采用lazy free机制，使用unlink命令假删除大key，之后后台线程进行异步惰性删除。")])])}),[],!1,null,null,null);a.default=v.exports}}]);